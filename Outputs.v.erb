Require Import Coq.Lists.List.
Require Import Coq.NArith.NArith.
Require Import Coq.Strings.Ascii.
Require Import ErrorHandlers.All.
Require Import FunctionNinjas.All.
Require Import ListString.All.
Require Import Computation.
Require Import Events.

Import ListNotations.
Local Open Scope char.

Module Spec.
  Inductive t : forall {A : Type}, C.t A -> A -> Type :=
  | Ret : forall {A : Type} {x : A}, t (C.Ret x) x
  | Bind : forall {A B : Type} {c_x : C.t A} {c_f : A -> C.t B}
    (x : A) {y : B}, t c_x x -> t (c_f x) y -> t (C.Bind c_x c_f) y
  | Join : forall {A B : Type} {c_x : C.t A} {c_y : C.t B}
    {x : A} {y : B}, t c_x x -> t c_y y -> t (C.Join c_x c_y) (x, y)
  | FirstLeft : forall {A B : Type} {c_x : C.t A} {c_y : C.t B}
    {x : A}, t c_x x -> t (C.First c_x c_y) (inl x)
  | FirstRight : forall {A B : Type} {c_x : C.t A} {c_y : C.t B}
    {y : B}, t c_y y -> t (C.First c_x c_y) (inr y)
  | Send : forall (command : Command.t) (request : Command.request command)
    (answer : Command.answer command), t (C.Send command request) answer.
End Spec.

Module Examples.
  Import C.Notations.

  (** Print one message. *)
  Module One.
    Definition echo : C.t unit :=
      let! message := C.Send Command.Read tt in
      C.Send Command.Write message.

    Definition echo_spec (message : LString.t) : Spec.t echo tt.
      unfold echo.
      eapply Spec.Bind.
      exact (Spec.Send Command.Read _ message).
      exact (Spec.Send Command.Write message tt).
    Defined.
  End One.

  (** Print a list of messages. *)
  Module Repeat.
    Fixpoint echo (fuel : nat) : C.t unit :=
      match fuel with
      | O => C.Ret tt
      | S fuel =>
        let! message := C.Send Command.Read tt in
        do! C.Send Command.Write message in
        echo fuel
      end.

    Fixpoint echo_spec (messages : list LString.t)
      : Spec.t (echo @@ List.length messages) tt.
      destruct messages as [|message messages]; unfold apply; simpl.
      - exact Spec.Ret.
      - eapply Spec.Bind.
        exact (Spec.Send Command.Read _ message).
        eapply Spec.Bind.
        exact (Spec.Send Command.Write message tt).
        exact (echo_spec messages).
    Defined.
  End Repeat.

  (** A buffer splitting a message into lists. *)
  Module Buffer.
    Fixpoint buffer (message : LString.t) : C.t unit :=
      match message with
      | [] => C.Ret tt
      | c :: message =>
        do! C.Send Command.Write [c] in
        buffer message
      end.

    Fixpoint buffer_spec (message : LString.t) : Spec.t (buffer message) tt.
      destruct message as [|c message].
      - exact Spec.Ret.
      - eapply Spec.Bind.
        exact (Spec.Send Command.Write [c] tt).
        exact (buffer_spec message).
    Defined.
  End Buffer.

  (** Print after serialization. *)
  Module Serializer.
    Definition serialize {A : Type} (print : A -> LString.t) (x : A)
      : C.t unit :=
      C.Send Command.Write (print x).

    Definition serialize_spec {A : Type} (print : A -> LString.t) (x : A)
      : Spec.t (serialize print x) tt.
      exact (Spec.Send Command.Write (print x) tt).
    Defined.
  End Serializer.

  (** Print using a buffer after serialization. *)
  Module BufferSerializer.
    Definition serialize {A : Type} (print : A -> LString.t) (x : A)
      : C.t unit :=
      Buffer.buffer (print x).

    Definition serialize_spec {A : Type} (print : A -> LString.t) (x : A)
      : Spec.t (serialize print x) tt.
      exact (Buffer.buffer_spec (print x)).
    Defined.
  End BufferSerializer.
End Examples.
