Require Import Coq.Lists.List.
Require Import Coq.NArith.NArith.
Require Import Coq.Strings.Ascii.
Require Import ErrorHandlers.All.
Require Import FunctionNinjas.All.
Require Import ListString.All.
Require Import Computation.
Require Import Events.

Import ListNotations.
Local Open Scope char.

Module Run.
  Inductive t : forall {A : Type}, C.t A -> A -> Type :=
  | Ret : forall {A : Type} {x : A}, t (C.Ret x) x
  | Bind : forall {A B : Type} {c_x : C.t A} {c_f : A -> C.t B}
    (x : A) {y : B}, t c_x x -> t (c_f x) y -> t (C.Bind c_x c_f) y
  | Join : forall {A B : Type} {c_x : C.t A} {c_y : C.t B}
    {x : A} {y : B}, t c_x x -> t c_y y -> t (C.Join c_x c_y) (x, y)
  | FirstLeft : forall {A B : Type} {c_x : C.t A} {c_y : C.t B}
    {x : A}, t c_x x -> t (C.First c_x c_y) (inl x)
  | FirstRight : forall {A B : Type} {c_x : C.t A} {c_y : C.t B}
    {y : B}, t c_y y -> t (C.First c_x c_y) (inr y)
  | Send : forall (command : Command.t) (request : Command.request command)
    (answer : Command.answer command), t (C.Send command request) answer.

  Definition seq {B : Type} {c_x : C.t unit} {c_y : C.t B} {y : B}
    (run_x : t c_x tt) (run_y : t c_y y) : t (C.Bind c_x (fun _ => c_y)) y.
    eapply Bind; [exact run_x | exact run_y].
  Defined.

  Definition _let {A B : Type} {e1 : A} {e2 : A -> C.t B} {r : B} (run : Run.t (let x := e1 in e2 x) r)
    : let x := e1 in Run.t (e2 x) r :=
    run.
End Run.

Module Examples.
  Import C.Notations.

  (** Print one message. *)
  Module One.
    Definition echo : C.t unit :=
      let! message := C.Send Command.Read tt in
      C.Send Command.Write message.

    Definition echo_spec (message : LString.t) : Run.t echo tt.
      unfold echo.
      eapply Run.Bind.
      exact (Run.Send Command.Read _ message).
      exact (Run.Send Command.Write message tt).
    Defined.
  End One.

  (** Print a list of messages. *)
  Module Repeat.
    Fixpoint echo (fuel : nat) : C.t unit :=
      match fuel with
      | O => C.Ret tt
      | S fuel =>
        let! message := C.Send Command.Read tt in
        do! C.Send Command.Write message in
        echo fuel
      end.

    Fixpoint echo_spec (messages : list LString.t)
      : Run.t (echo @@ List.length messages) tt.
      destruct messages as [|message messages]; unfold apply; simpl.
      - exact Run.Ret.
      - eapply Run.Bind.
        exact (Run.Send Command.Read _ message).
        eapply Run.Bind.
        exact (Run.Send Command.Write message tt).
        exact (echo_spec messages).
    Defined.
  End Repeat.

  (** A buffer splitting a message into lists. *)
  Module Buffer.
    Fixpoint buffer (message : LString.t) : C.t unit :=
      match message with
      | [] => C.Ret tt
      | c :: message =>
        do! C.Send Command.Write [c] in
        buffer message
      end.

    Fixpoint buffer_spec (message : LString.t) : Run.t (buffer message) tt.
      destruct message as [|c message].
      - exact Run.Ret.
      - eapply Run.Bind.
        exact (Run.Send Command.Write [c] tt).
        exact (buffer_spec message).
    Defined.
  End Buffer.

  (** Print after serialization. *)
  Module Serializer.
    Definition serialize {A : Type} (print : A -> LString.t) (x : A)
      : C.t unit :=
      C.Send Command.Write (print x).

    Definition serialize_spec {A : Type} (print : A -> LString.t) (x : A)
      : Run.t (serialize print x) tt.
      exact (Run.Send Command.Write (print x) tt).
    Defined.
  End Serializer.

  (** Print using a buffer after serialization. *)
  Module BufferSerializer.
    Definition serialize {A : Type} (print : A -> LString.t) (x : A)
      : C.t unit :=
      Buffer.buffer (print x).

    Definition serialize_spec {A : Type} (print : A -> LString.t) (x : A)
      : Run.t (serialize print x) tt.
      exact (Buffer.buffer_spec (print x)).
    Defined.
  End BufferSerializer.
End Examples.
