Require Import Coq.Lists.List.
Require Import Coq.NArith.NArith.
Require Import Coq.Strings.Ascii.
Require Import ErrorHandlers.All.
Require Import FunctionNinjas.All.
Require Import ListString.All.
Require Import Computation.
Require Import Events.

Import ListNotations.
Local Open Scope char.

Module Spec.
  Inductive t : forall {A : Type}, C.t A -> A -> Type :=
  | Ret : forall {A : Type} (x : A), t (C.Ret x) x
  | Bind : forall {A B : Type} {c_x : C.t A} {c_f : A -> C.t B} {x : A} {y : B},
    t c_x x -> t (c_f x) y -> t (C.Bind c_x c_f) y
  | Join : forall {A B : Type} {c_x : C.t A} {c_y : C.t B} {x : A} {y : B},
    t c_x x -> t c_y y -> t (C.Join c_x c_y) (x, y)
  | FirstLeft : forall {A B : Type} {c_x : C.t A} {c_y : C.t B} {x : A},
    t c_x x -> t (C.First c_x c_y) (inl x)
  | FirstRight : forall {A B : Type} {c_x : C.t A} {c_y : C.t B} {y : B},
    t c_y y -> t (C.First c_x c_y) (inr y)
  | Send : forall (command : Command.t) (request : Command.request command)
    (answer : Command.answer command), t (C.Send command request) answer.
End Spec.

(*Module Examples.
  Import C.Notations.

  Module One.
    Definition echo : C.t unit :=
      let! message := C.Send Command.ConsoleRead tt in
      do! C.Send Command.ConsoleWrite message in
      C.Ret tt.

    Definition echo_spec (message : LString.t) : Spec.t echo.
      unfold echo.
      apply Spec.Send with (answer := message).
      apply Spec.Send with (request := message) (answer := true).
      apply Spec.Ret.
    Defined.
    Compute Spec.run @@ echo_spec (LString.s "hello").
  End One.

  Module Repeat.
    Fixpoint echo (fuel : nat) : C.t :=
      match fuel with
      | O => C.Ret
      | S fuel =>
        C.Send Command.ConsoleRead tt (fun message =>
          C.Send Command.ConsoleWrite message (fun _ =>
            echo fuel))
      end.

    Fixpoint echo_spec (messages : list LString.t)
      : Spec.t (echo @@ List.length messages).
      destruct messages as [|message messages]; unfold apply; simpl.
      - apply Spec.Ret.
      - apply Spec.Send with (answer := message).
        apply Spec.Send with (request := message) (answer := true).
        apply (echo_spec messages).
    Defined.
    Compute Spec.run @@ echo_spec [LString.s "hello"; LString.s "world"].
  End Repeat.
End Examples.*)

(*Module SpecC.
  Inductive t : Type -> Commands.t -> Type :=
  | Ret : forall {A : Type}, A -> t A Commands.Ret
  | Bind : forall {A B : Type} {commands_x commands_y : Commands.t},
    t A commands_x -> (A -> t B commands_y) -> t B (Commands.Bind commands_x commands_y)
  | Send : forall (command : Command.t) (commands : Command.answer command -> Commands.t),
    Command.request command ->
    (forall (answer : Command.answer command), t unit (commands answer)) ->
    t unit (Commands.Send command commands).
  
  Fixpoint run {A : Type} {commands : Commands.t} (x : t A commands) : A :=
    match x with
    | Ret <%= "_" if version[0..2] == "8.4" %> x => x
    | Bind <%= "_ _ _ _" if version[0..2] == "8.4" %> x f => run (f (run x))
    | Send _ _ _ _ => tt
    end.
End SpecC.

Module SpecSystem.
  Inductive t : Commands.t -> Type :=
  | Ret : t Commands.Ret
  | Bind : forall {A B : Type} {commands_x commands_y : Commands.t},
    t commands_x -> t commands_y -> t (Commands.Bind commands_x commands_y)
  | Send : forall (command : Command.t) {commands : Command.answer command -> Commands.t},
    (Command.request command -> {answer : Command.answer command & t (commands answer)}) ->
    t (Commands.Send command commands).
End SpecSystem.

(*Module SpecTrace.
  Inductive t : Type :=
  | Ret : t
  | Bind : t -> t -> t
  | Send : forall (command : Command.t),
    Command.request command -> Command.answer command -> t -> t.

  Fixpoint run {A : Type} {commands : Commands.t} (x : SpecC.t A commands) (system : SpecSystem.t commands)
    : t :=
    match x with
    | SpecC.Ret _ _ =>
      match system with
      | SpecSystem.Ret => Ret
      end
    | SpecC.Bind _ _ _ _ x f =>
      match system with
      | System.Bind system_x system_f =>
        Option.bind (run x system_x) (fun trace_x =>
        Option.bind (run (f @@ C.run x) system_f) (fun trace_y =>
        Some (Bind trace_x trace_y)))
      | _ => None
      end
    | SpecC.Send command commands request handler =>
      match system with
      | System.Send system_command system_handler =>
        match Command.eq_dec system_command command with
        | left Heq =>
          let system_handler := eq_rect system_command (fun c => Command.request c -> Command.answer c * System.t)
            system_handler command Heq in
          let (answer, system) := system_handler request in
          Option.bind (run (handler answer) system) (fun trace_handler =>
          Some (Send command request answer trace_handler))
        | right _ => None
        end
      | _ => None
      end
    end.

    destruct commands.
    - exact Ret.
    - inversion_clear x; inversion_clear s.
      exact (
        let trace_x := run _ _ X X1 in
        let trace_y := run _ _ (X0 (SpecC.run X)) X2 in
        Bind trace_x trace_y).
    - generalize s; clear s.
      inversion x.
      inversion_clear s.
      assert (commands0 = t0).
      injection H2.
      refine (
        let (answer, s) := X0 H1 in
        let x := X answer in
        let traces := run _ _ x s in
        Send command H answer traces).
End SpecTrace.
    

Module System.
  Inductive t : Commands.t -> Type :=
  | Ret : t Commands.Ret
  | Bind : forall {commands_x commands_y : Commands.t},
    t commands_x -> t commands_y -> t (Commands.Bind commands_x commands_y)
  | Send : forall (command : Command.t)
    (handler : Command.answer command -> Commands.t),
    (Command.request command ->
      {answer : Command.answer command & t (handler answer)}) ->
    t (Commands.Send command handler).

  Fixpoint run {A : Type} (x : C.t A) (s : t (Commands.eval x)) : A.
    destruct x as [A x | A B x f | ].
    - exact x.
    - simpl in s.
      inversion_clear s.
      exact (
        let _ := run _ x X in
        run _ (f (C.run x)) X0).
    - simpl in s.
      inversion s.
      refine (let (answer, s_answer) := X r in
        run _ (t0 answer) _).
      assert (handler0 = (fun answer : Command.answer command => Commands.eval (t0 answer))).
      congruence.
intuition.

      assert (answer0 ).
      Check
        let (answer, s_answer) := X r in
        run _ (t0 answer) s_answer.
      

  Fixpoint run {A : Type} (x : C.t A) : t (snd (Outputs.run x)) -> A :=
    match x in C.t A return t (snd (Outputs.run x)) -> A with
    | C.Ret _ x => fun _ => x
    | C.Bind _ _ x f => fun s =>
      match s in t (Outputs.Bind _ _) return A with
      | Bind _ _ s_x s_f =>
        let x := run x s_x in
        run (f x) s_f
      end
    end.
End System.*)*)