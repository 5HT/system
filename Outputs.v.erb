Require Import Coq.Lists.List.
Require Import Coq.NArith.NArith.
Require Import Coq.Strings.Ascii.
Require Import ErrorHandlers.All.
Require Import FunctionNinjas.All.
Require Import ListString.All.
Require Import Computation.
Require Import Events.

Import ListNotations.
Local Open Scope char.

Module Run.
  Inductive t : C.t -> Type :=
  | Ret : t C.Ret
  | Par : forall {c1 c2 : C.t}, t c1 -> t c2 -> t (C.Par c1 c2)
  | Send : forall (command : Command.t) (request : Command.request command)
    (answer : Command.answer command) {handler : Command.answer command -> C.t},
    t (handler answer) -> t (C.Send command request handler).
End Run.

Module Examples.
  Import C.Notations.

  (** Hello world. *)
  Module HelloWorld.
    Definition program : C.t :=
      do! Command.Write @ LString.s "Hello world!" in
      C.Ret.

    Definition run : Run.t program.
      apply (Run.Send Command.Write (LString.s "Hello world!") tt).
      exact Run.Ret.
    Defined.
  End HelloWorld.

  (** Echo one message. *)
  Module EchoOne.
    Definition program : C.t :=
      let! message := Command.Read @ tt in
      do! Command.Write @ message in
      C.Ret.

    Definition spec (message : LString.t) : Run.t program.
      apply (Run.Send Command.Read tt message).
      apply (Run.Send Command.Write message tt).
      exact Run.Ret.
    Defined.
  End EchoOne.

  (** Echo a list of messages in sequence. *)
  Module EchoOrdered.
    Fixpoint program (fuel : nat) : C.t :=
      match fuel with
      | O => C.Ret
      | S fuel =>
        let! message := Command.Read @ tt in
        do! Command.Write @ message in
        program fuel
      end.

    Fixpoint spec (messages : list LString.t)
      : Run.t (program (List.length messages)).
      destruct messages as [|message messages].
      - exact Run.Ret.
      - apply (Run.Send Command.Read _ message).
        apply (Run.Send Command.Write message tt).
        exact (spec messages).
    Defined.
  End EchoOrdered.

  (** Echo a list of messages in parallel. *)
  Module EchoUnordered.
    Fixpoint program (fuel : nat) : C.t :=
      match fuel with
      | O => C.Ret
      | S fuel =>
        C.Par (program fuel) (
          let! message := Command.Read @ tt in
          do! Command.Write @ message in
          C.Ret)
      end.

    Fixpoint spec (messages : list LString.t)
      : Run.t (program (List.length messages)).
      destruct messages as [|message messages].
      - exact Run.Ret.
      - apply Run.Par.
        * exact (spec messages).
        * apply (Run.Send Command.Read _ message).
          apply (Run.Send Command.Write message tt).
          exact Run.Ret.
    Defined.
  End EchoUnordered.

  Module TimeServer.
    Parameter string_of_time : N -> LString.t.

    Definition handle_client (client_socket : ClientSocketId.t) : C.t :=
      let! time := Command.Time @ tt in
      let message := string_of_time time in
      let! is_written := Command.ClientSocketWrite @ (client_socket, message) in
      if is_written then
        do! Command.ClientSocketClose @ client_socket in
        C.Ret
      else
        C.Ret.

    Fixpoint accept_clients (server_socket : ServerSocketId.t) (fuel : nat) : C.t :=
      match fuel with
      | O => C.Ret
      | S fuel =>
        C.Par (accept_clients server_socket fuel) (
          let! client_socket := Command.ServerSocketAccept @ server_socket in
          match client_socket with
          | None => C.Ret
          | Some client_socket => handle_client client_socket
          end)
      end.

    Definition program (port : N) (fuel : nat) : C.t :=
      let! server_socket := Command.ServerSocketBind @ port in
      match server_socket with
      | None => C.Ret
      | Some server_socket => accept_clients server_socket fuel
      end.
  End TimeServer.

  (*(** A buffer splitting a message into lists. *)
  Module Buffer.
    Fixpoint buffer (message : LString.t) : C.t unit :=
      match message with
      | [] => C.Ret tt
      | c :: message =>
        do! C.Send Command.Write [c] in
        buffer message
      end.

    Fixpoint buffer_spec (message : LString.t) : Run.t (buffer message) tt.
      destruct message as [|c message].
      - exact Run.Ret.
      - eapply Run.Bind.
        exact (Run.Send Command.Write [c] tt).
        exact (buffer_spec message).
    Defined.
  End Buffer.

  (** Print after serialization. *)
  Module Serializer.
    Definition serialize {A : Type} (print : A -> LString.t) (x : A)
      : C.t unit :=
      C.Send Command.Write (print x).

    Definition serialize_spec {A : Type} (print : A -> LString.t) (x : A)
      : Run.t (serialize print x) tt.
      exact (Run.Send Command.Write (print x) tt).
    Defined.
  End Serializer.

  (** Print using a buffer after serialization. *)
  Module BufferSerializer.
    Definition serialize {A : Type} (print : A -> LString.t) (x : A)
      : C.t unit :=
      Buffer.buffer (print x).

    Definition serialize_spec {A : Type} (print : A -> LString.t) (x : A)
      : Run.t (serialize print x) tt.
      exact (Buffer.buffer_spec (print x)).
    Defined.
  End BufferSerializer.*)
End Examples.
