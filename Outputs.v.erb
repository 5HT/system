Require Import Coq.Lists.List.
Require Import Coq.NArith.NArith.
Require Import Coq.Strings.Ascii.
Require Import ErrorHandlers.All.
Require Import FunctionNinjas.All.
Require Import ListString.All.
Require Import Computation.

Import ListNotations.
Local Open Scope char.

Module Spec.
  Inductive t {api : API.t} : forall {A : Type}, C.t api A -> A -> Type :=
  | Ret : forall {A : Type} {x : A}, t (C.Ret x) x
  | Bind : forall {A B : Type} {c_x : C.t api A} {c_f : A -> C.t api B}
    (x : A) {y : B}, t c_x x -> t (c_f x) y -> t (C.Bind c_x c_f) y
  | Join : forall {A B : Type} {c_x : C.t api A} {c_y : C.t api B}
    {x : A} {y : B}, t c_x x -> t c_y y -> t (C.Join c_x c_y) (x, y)
  | FirstLeft : forall {A B : Type} {c_x : C.t api A} {c_y : C.t api B}
    {x : A}, t c_x x -> t (C.First c_x c_y) (inl x)
  | FirstRight : forall {A B : Type} {c_x : C.t api A} {c_y : C.t api B}
    {y : B}, t c_y y -> t (C.First c_x c_y) (inr y)
  | Send : forall (command : API.command api) (request : API.request api command)
    (answer : API.answer api command), t (C.Send api command request) answer.
End Spec.

Module Examples.
  Import C.Notations.

  Module SocketsReader.
    Definition api : API.t := {|
      API.command := unit;
      API.request := fun _ => LString.t;
      API.answer := fun _ => unit |}.

    Definition full_api := API.add System.api api.

    Fixpoint read_one (fuel : nat) (client : ClientSocketId.t)
      : C.t full_api unit :=
      match fuel with
      | O => C.Ret tt
      | S fuel =>
        let! message := C.Send full_api (inl System.ClientSocketRead) client in
        C.Send full_api (inr tt) message
      end.

    (*Fixpoint read_all (clients : list ClientSocketId.t) : C.t System.api unit :=
      match *)
  End SocketsReader.
End Examples.

(*Module Examples.
  Import C.Notations.

  (** Print one message. *)
  Module One.
    Definition echo : C.t unit :=
      let! message := C.Send Command.ConsoleRead tt in
      do! C.Send Command.ConsoleWrite message in
      C.Ret tt.

    Definition echo_spec (message : LString.t) : Spec.t echo tt.
      unfold echo.
      eapply Spec.Bind.
      exact (Spec.Send Command.ConsoleRead _ message).
      eapply Spec.Bind.
      exact (Spec.Send Command.ConsoleWrite message true).
      exact Spec.Ret.
    Defined.
  End One.

  (** Print a list of messages. *)
  Module Repeat.
    Fixpoint echo (fuel : nat) : C.t unit :=
      match fuel with
      | O => C.Ret tt
      | S fuel =>
        let! message := C.Send Command.ConsoleRead tt in
        do! C.Send Command.ConsoleWrite message in
        echo fuel
      end.

    Fixpoint echo_spec (messages : list LString.t)
      : Spec.t (echo @@ List.length messages) tt.
      destruct messages as [|message messages]; unfold apply; simpl.
      - exact Spec.Ret.
      - eapply Spec.Bind.
        exact (Spec.Send Command.ConsoleRead _ message).
        eapply Spec.Bind.
        exact (Spec.Send Command.ConsoleWrite message true).
        exact (echo_spec messages).
    Defined.
  End Repeat.

  (** A buffer splitting a message into lists. *)
  Module Buffer.
    Fixpoint buffer (message : LString.t) : C.t unit :=
      match message with
      | [] => C.Ret tt
      | c :: message =>
        do! C.Send Command.ConsoleWrite [c] in
        buffer message
      end.

    Fixpoint buffer_spec (message : LString.t) : Spec.t (buffer message) tt.
      destruct message as [|c message].
      - exact Spec.Ret.
      - eapply Spec.Bind.
        exact (Spec.Send Command.ConsoleWrite [c] true).
        exact (buffer_spec message).
    Defined.
  End Buffer.

  (** A buffer checking that each output operation succeeds. *)
  Module CheckingBuffer.
    Fixpoint buffer (message : LString.t) : C.t bool :=
      match message with
      | [] => C.Ret true
      | c :: message =>
        let! is_success := C.Send Command.ConsoleWrite [c] in
        if is_success then
          buffer message
        else
          C.Ret false
      end.

    Fixpoint buffer_spec_ok (message : LString.t)
      : Spec.t (buffer message) true.
      destruct message as [|c message].
      - exact Spec.Ret.
      - eapply Spec.Bind.
        exact (Spec.Send Command.ConsoleWrite [c] true).
        exact (buffer_spec_ok message).
    Defined.

    Definition buffer_spec_fail (c : Ascii.ascii) (message : LString.t)
      : Spec.t (buffer (c :: message)) false.
      eapply Spec.Bind.
      exact (Spec.Send Command.ConsoleWrite [c] false).
      exact Spec.Ret.
    Defined.
  End CheckingBuffer.

  (** Print after serialization. *)
  Module Serializer.
    Definition serialize {A : Type} (print : A -> LString.t) (x : A)
      : C.t bool :=
      C.Send Command.ConsoleWrite (print x).

    Definition serialize_spec {A : Type} (print : A -> LString.t) (x : A)
      (is_success : bool) : Spec.t (serialize print x) is_success.
      exact (Spec.Send Command.ConsoleWrite (print x) is_success).
    Defined.
  End Serializer.

  (** Print using a buffer after serialization. *)
  Module BufferSerializer.
    Definition serialize {A : Type} (print : A -> LString.t) (x : A)
      : C.t bool :=
      CheckingBuffer.buffer (print x).

    Definition serialize_spec {A : Type} (print : A -> LString.t) (x : A)
      : Spec.t (serialize print x) true.
      exact (CheckingBuffer.buffer_spec_ok (print x)).
    Defined.
  End BufferSerializer.

  Module Database.
    Fixpoint serve_two (client1 client2 : ClientSocketId.t) (fuel : nat)
      (value : LString.t) : C.t bool :=
      match fuel with
      | O => C.Send Command.ConsoleWrite value
      | S fuel =>
        let! first := C.First
          (C.Send Command.ClientSocketReadReady client1)
          (C.Send Command.ClientSocketReadReady client2) in
        let client :=
          match first with
          | inl _ => client1
          | inr _ => client2
          end in
        let! request := C.Send Command.ClientSocketRead client in
        serve_two client1 client2 fuel request
      end.

    (*Fixpoint serve (fuel : nat) (client : ClientSocketId.t) : C.t unit :=
      match fuel with
      | O => C.Ret tt
      | S fuel =>
        let! request := C.Send Command.ClientSocketRead client in
        match request with
        | None => C.Ret tt
        | Some [] => 
        end
      end.*)
  End Database.
End Examples.*)
