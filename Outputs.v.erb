Require Import Coq.Lists.List.
Require Import Coq.NArith.NArith.
Require Import Coq.Strings.Ascii.
Require Import ErrorHandlers.All.
Require Import FunctionNinjas.All.
Require Import ListString.All.
Require Import Computation.
Require Import Events.

Import ListNotations.
Local Open Scope char.

(*Module Spec.
  Inductive t {run : forall {A : Type}, C.t A -> A} : forall {A : Type}, C.t A -> Type :=
  | Ret : forall {A : Type} (x : A), t (C.Ret x)
  | Bind : forall {A B : Type} {c_x : C.t A} {c_f : A -> C.t B},
    t c_x -> t (c_f (run _ c_x)) -> t (C.Bind c_x c_f)
  | Join : forall {A B : Type} {c_x : C.t A} {c_y : C.t B},
    t c_x -> t c_y -> t (C.Join c_x c_y)
  | First : forall {A B : Type} {c_x : C.t A} {c_y : C.t B},
    (t c_x + t c_y) -> t (C.First c_x c_y)
  | Send : forall (command : Command.t) (request : Command.request command),
    Command.answer command -> t (C.Send command request).

  Fixpoint run {A : Type} {x : C.t A} (spec : t x) : A :=
    match spec with
    | Ret <%= "_" if version[0..2] == "8.4" %> x => x
    | Bind <%= "_ _ _ _" if version[0..2] == "8.4" %> spec_x spec_f =>
      let x := run spec_x in
      run @@ spec_f x
    | Join <%= "_ _ _ _" if version[0..2] == "8.4" %> spec_x spec_y =>
      (run spec_x, run spec_y)
    | First <%= "_ _ _ _" if version[0..2] == "8.4" %> spec_xy =>
      match spec_xy with
      | inl spec_x => inl @@ run spec_x
      | inr spec_y => inr @@ run spec_y
      end
    | Send <%= "_" if version[0..2] == "8.4" %> _ _ _ _ spec => run spec
    end.
End Spec.*)

(*Module Spec.
  Inductive t : forall {A : Type}, C.t A -> Type :=
  | Ret : forall {A : Type} (x : A), t (C.Ret x)
  | Bind : forall {A B : Type} {x : C.t A} {f : A -> C.t B} (v_x : A), t x ->
    t (f v_x) -> t (C.Bind x f)
  | Join : forall {A B : Type} {x : C.t A} {y : C.t B}, t x -> t y -> t (C.Join x y)
  | First : forall {A B : Type} {x : C.t A} {y : C.t B}, (t x + t y) -> t (C.First x y)
  | Send : forall {A : Type} (command : Command.t) (request : Command.request command)
    (handler : Command.answer command -> A), Command.answer command ->
    t (C.Send command request).

  Fixpoint run {A : Type} {x : C.t A} (spec : t x) : A :=
    match spec with
    | Ret <%= "_" if version[0..2] == "8.4" %> x => x
    | Bind <%= "_ _ _ _" if version[0..2] == "8.4" %> spec_x spec_f =>
      let x := run spec_x in
      run @@ spec_f x
    | Join <%= "_ _ _ _" if version[0..2] == "8.4" %> spec_x spec_y =>
      (run spec_x, run spec_y)
    | First <%= "_ _ _ _" if version[0..2] == "8.4" %> spec_xy =>
      match spec_xy with
      | inl spec_x => inl @@ run spec_x
      | inr spec_y => inr @@ run spec_y
      end
    | Send <%= "_" if version[0..2] == "8.4" %> _ _ _ _ spec => run spec
    end.
End Spec.*)

Module Spec.
  Inductive t : forall {A : Type}, C.t A -> A -> Type :=
  | Ret : forall {A : Type} (x : A), t (C.Ret x) x
  | Bind : forall {A B : Type} {c_x : C.t A} {c_f : A -> C.t B} (x : A) {y : B},
    t c_x x -> t (c_f x) y -> t (C.Bind c_x c_f) y
  | Join : forall {A B : Type} {c_x : C.t A} {c_y : C.t B} {x : A} {y : B},
    t c_x x -> t c_y y -> t (C.Join c_x c_y) (x, y)
  | FirstLeft : forall {A B : Type} {c_x : C.t A} {c_y : C.t B} {x : A},
    t c_x x -> t (C.First c_x c_y) (inl x)
  | FirstRight : forall {A B : Type} {c_x : C.t A} {c_y : C.t B} {y : B},
    t c_y y -> t (C.First c_x c_y) (inr y)
  | Send : forall (command : Command.t) (request : Command.request command)
    (answer : Command.answer command), t (C.Send command request) answer.

  (*Fixpoint run {A : Type} {c_x : C.t A} {x : A} (spec : t c_x x) : A :=
    match spec with
    | Ret <%= "_" if version[0..2] == "8.4" %> x => x
    | Bind x spec_x spec_f =>
      (* let x := run spec_x in *)
      run spec_f
    | Join <%= "_ _ _ _" if version[0..2] == "8.4" %> spec_x spec_y =>
      (run spec_x, run spec_y)
    | FirstLeft <%= "_ _ _ _" if version[0..2] == "8.4" %> spec_x =>
      inl @@ run spec_x
    | FirstRight <%= "_ _ _ _" if version[0..2] == "8.4" %> spec_y =>
      inr @@ run spec_y
    | Send _ _ answer => answer
    end.*)
End Spec.

Module Examples.
  Import C.Notations.

  Module One.
    Definition echo : C.t unit :=
      let! message := C.Send Command.ConsoleRead tt in
      do! C.Send Command.ConsoleWrite message in
      C.Ret tt.

    Definition echo_spec (message : LString.t) : Spec.t echo tt.
      unfold echo.
      eapply Spec.Bind.
      - apply Spec.Send with (answer := message).
      - eapply Spec.Bind.
        + apply Spec.Send with (answer := true).
        + apply Spec.Ret.
    Defined.
    Print echo_spec.
  End One.

  Module Repeat.
    Fixpoint echo (fuel : nat) : C.t :=
      match fuel with
      | O => C.Ret
      | S fuel =>
        C.Send Command.ConsoleRead tt (fun message =>
          C.Send Command.ConsoleWrite message (fun _ =>
            echo fuel))
      end.

    Fixpoint echo_spec (messages : list LString.t)
      : Spec.t (echo @@ List.length messages).
      destruct messages as [|message messages]; unfold apply; simpl.
      - apply Spec.Ret.
      - apply Spec.Send with (answer := message).
        apply Spec.Send with (request := message) (answer := true).
        apply (echo_spec messages).
    Defined.
    Compute Spec.run @@ echo_spec [LString.s "hello"; LString.s "world"].
  End Repeat.
End Examples.

(*Module SpecC.
  Inductive t : Type -> Commands.t -> Type :=
  | Ret : forall {A : Type}, A -> t A Commands.Ret
  | Bind : forall {A B : Type} {commands_x commands_y : Commands.t},
    t A commands_x -> (A -> t B commands_y) -> t B (Commands.Bind commands_x commands_y)
  | Send : forall (command : Command.t) (commands : Command.answer command -> Commands.t),
    Command.request command ->
    (forall (answer : Command.answer command), t unit (commands answer)) ->
    t unit (Commands.Send command commands).
  
  Fixpoint run {A : Type} {commands : Commands.t} (x : t A commands) : A :=
    match x with
    | Ret <%= "_" if version[0..2] == "8.4" %> x => x
    | Bind <%= "_ _ _ _" if version[0..2] == "8.4" %> x f => run (f (run x))
    | Send _ _ _ _ => tt
    end.
End SpecC.

Module SpecSystem.
  Inductive t : Commands.t -> Type :=
  | Ret : t Commands.Ret
  | Bind : forall {A B : Type} {commands_x commands_y : Commands.t},
    t commands_x -> t commands_y -> t (Commands.Bind commands_x commands_y)
  | Send : forall (command : Command.t) {commands : Command.answer command -> Commands.t},
    (Command.request command -> {answer : Command.answer command & t (commands answer)}) ->
    t (Commands.Send command commands).
End SpecSystem.

(*Module SpecTrace.
  Inductive t : Type :=
  | Ret : t
  | Bind : t -> t -> t
  | Send : forall (command : Command.t),
    Command.request command -> Command.answer command -> t -> t.

  Fixpoint run {A : Type} {commands : Commands.t} (x : SpecC.t A commands) (system : SpecSystem.t commands)
    : t :=
    match x with
    | SpecC.Ret _ _ =>
      match system with
      | SpecSystem.Ret => Ret
      end
    | SpecC.Bind _ _ _ _ x f =>
      match system with
      | System.Bind system_x system_f =>
        Option.bind (run x system_x) (fun trace_x =>
        Option.bind (run (f @@ C.run x) system_f) (fun trace_y =>
        Some (Bind trace_x trace_y)))
      | _ => None
      end
    | SpecC.Send command commands request handler =>
      match system with
      | System.Send system_command system_handler =>
        match Command.eq_dec system_command command with
        | left Heq =>
          let system_handler := eq_rect system_command (fun c => Command.request c -> Command.answer c * System.t)
            system_handler command Heq in
          let (answer, system) := system_handler request in
          Option.bind (run (handler answer) system) (fun trace_handler =>
          Some (Send command request answer trace_handler))
        | right _ => None
        end
      | _ => None
      end
    end.

    destruct commands.
    - exact Ret.
    - inversion_clear x; inversion_clear s.
      exact (
        let trace_x := run _ _ X X1 in
        let trace_y := run _ _ (X0 (SpecC.run X)) X2 in
        Bind trace_x trace_y).
    - generalize s; clear s.
      inversion x.
      inversion_clear s.
      assert (commands0 = t0).
      injection H2.
      refine (
        let (answer, s) := X0 H1 in
        let x := X answer in
        let traces := run _ _ x s in
        Send command H answer traces).
End SpecTrace.
    

Module System.
  Inductive t : Commands.t -> Type :=
  | Ret : t Commands.Ret
  | Bind : forall {commands_x commands_y : Commands.t},
    t commands_x -> t commands_y -> t (Commands.Bind commands_x commands_y)
  | Send : forall (command : Command.t)
    (handler : Command.answer command -> Commands.t),
    (Command.request command ->
      {answer : Command.answer command & t (handler answer)}) ->
    t (Commands.Send command handler).

  Fixpoint run {A : Type} (x : C.t A) (s : t (Commands.eval x)) : A.
    destruct x as [A x | A B x f | ].
    - exact x.
    - simpl in s.
      inversion_clear s.
      exact (
        let _ := run _ x X in
        run _ (f (C.run x)) X0).
    - simpl in s.
      inversion s.
      refine (let (answer, s_answer) := X r in
        run _ (t0 answer) _).
      assert (handler0 = (fun answer : Command.answer command => Commands.eval (t0 answer))).
      congruence.
intuition.

      assert (answer0 ).
      Check
        let (answer, s_answer) := X r in
        run _ (t0 answer) s_answer.
      

  Fixpoint run {A : Type} (x : C.t A) : t (snd (Outputs.run x)) -> A :=
    match x in C.t A return t (snd (Outputs.run x)) -> A with
    | C.Ret _ x => fun _ => x
    | C.Bind _ _ x f => fun s =>
      match s in t (Outputs.Bind _ _) return A with
      | Bind _ _ s_x s_f =>
        let x := run x s_x in
        run (f x) s_f
      end
    end.
End System.*)*)