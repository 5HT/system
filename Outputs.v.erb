Require Import Coq.Lists.List.
Require Import Coq.NArith.NArith.
Require Import Coq.Strings.Ascii.
Require Import ErrorHandlers.All.
Require Import FunctionNinjas.All.
Require Import ListString.All.
Require Import Computation.
Require Import Events.

Import ListNotations.
Local Open Scope char.

Module System.
  Inductive t : Type :=
  | Ret : t
  | Seq : t -> t -> t
  | Send : forall (command : Command.t),
    (Command.request command -> Command.answer command) ->
    (Command.request command -> t) -> t.
End System.

Module Trace.
  Inductive t : Type :=
  | Ret : t
  | Seq : t -> t -> t
  | Send : forall (command : Command.t),
    Command.request command -> Command.answer command -> t -> t.

  Fixpoint run (x : C.t) (system : System.t) : option t :=
    match x with
    | C.Ret =>
      match system with
      | System.Ret => Some Ret
      | _ => None
      end
    | C.Seq x y =>
      match system with
      | System.Seq system_x system_y =>
        Option.bind (run x system_x) (fun trace_x =>
        Option.bind (run y system_y) (fun trace_y =>
        Some (Seq trace_x trace_y)))
      | _ => None
      end
    | C.Send command request handler =>
      match system with
      | System.Send system_command answer system =>
        match Command.eq_dec system_command command with
        | left Heq =>
          let answer := eq_rect system_command (fun c => Command.request c -> Command.answer c)
            answer command Heq request in
          let system := eq_rect system_command (fun c => Command.request c -> System.t)
            system command Heq request in
          Option.bind (run (handler answer) system) (fun trace_handler =>
          Some (Send command request answer trace_handler))
        | right _ => None
        end
      | _ => None
      end
    end.

  Fixpoint compatible (x : C.t) (system : System.t) : bool :=
    match x with
    | C.Ret =>
      match system with
      | System.Ret => true
      | _ => false
      end
    | C.Seq x y =>
      match system with
      | System.Seq system_x system_y =>
        andb (compatible x system_x) (compatible y system_y)
      | _ => false
      end
    | C.Send command request handler =>
      match system with
      | System.Send system_command answer system =>
        match Command.eq_dec system_command command with
        | left Heq =>
          let answer := eq_rect system_command (fun c => Command.request c -> Command.answer c)
            answer command Heq request in
          let system := eq_rect system_command (fun c => Command.request c -> System.t)
            system command Heq request in
          compatible (handler answer) system
        | right _ => false
        end
      | _ => false
      end
    end.

  (*Lemma compatible_implies_result : forall {A : Type} (x : C.t A) (system : System.t),
    compatible x system = true -> exists (trace : t), run x system = Some trace.
    intros H x; induction x; intros system Hcompatible; destruct system;
      simpl in *; try congruence.
    - now exists Ret.
    - destruct (andb_prop _ _ Hcompatible) as [Hx Hf].
      destruct (IHx _ Hx) as [trace_x Hrun_x].
      destruct (H _ _ Hf) as [trace_f Hrun_f].
      exists (Bind trace_x trace_f).
      rewrite Hrun_x; simpl.
      now unfold apply; rewrite Hrun_f; simpl.
    - destruct (Command.eq_dec command0 command) as [Heq | Hneq]; try congruence.
      destruct (H _ _ Hcompatible) as [trace Hrun].
      exists (
        let answer := eq_rect command0 (fun c => Command.request c -> Command.answer c)
          a command Heq r in
        Send _ r answer trace).
      now rewrite Hrun; simpl.
  Qed.*)
End Trace.

Module Commands.
  Inductive t : Set :=
  | Ret : t
  | Seq : t -> t -> t
  | Send : forall (command : Command.t),
    (Command.request command -> Command.answer command -> t) -> t.

  Fixpoint of_program (x : C.t) : t :=
    match x with
    | C.Ret => Ret
    | C.Seq x y => Seq (of_program x) (of_program y)
    | C.Send command _ handler =>
      Send command (fun _ answer => of_program @@ handler answer)
    end.

  Fixpoint of_system (system : System.t) : t :=
    match system with
    | System.Ret => Ret
    | System.Seq system_x system_f =>
      Seq (of_system system_x) (of_system system_f)
    | System.Send command _ system =>
      Send command (fun request _ => of_system @@ system request)
    end.
End Commands.

Module Spec.
  Inductive t : C.t -> Type :=
  | Ret : t C.Ret
  | Seq : forall (x y : C.t) (system_x : t x) (system_y : t y), t (C.Seq x y)
  | Send : forall (command : Command.t) (request : Command.request command)
    (handler : Command.answer command -> C.t) (answer : Command.answer command),
    t (handler answer) -> t (C.Send command request handler).
End Spec.

Module Examples.
  Module One.
    Definition echo : C.t :=
      C.Send Command.ConsoleRead tt (fun message =>
        C.Send Command.ConsoleWrite message (fun _ => C.Ret)).
    Compute Commands.of_program echo.

    Definition echo_system : System.t :=
      System.Send Command.ConsoleRead (fun _ => LString.s "hello") (fun _ =>
        System.Send Command.ConsoleWrite (fun _ => true) (fun _ => System.Ret)).
    Compute Commands.of_system echo_system.

    Compute Trace.run echo echo_system.

    Definition echo_spec (message : LString.t) : Spec.t echo.
      unfold echo.
      apply Spec.Send with (answer := message).
      apply Spec.Send with (answer := true).
      apply Spec.Ret.
    Defined.
  End One.

  Module Repeat.
    Fixpoint echo (fuel : nat) : C.t :=
      match fuel with
      | O => C.Ret
      | S fuel =>
        C.Send Command.ConsoleRead tt (fun message =>
          C.Send Command.ConsoleWrite message (fun _ =>
            echo fuel))
      end.
    Compute Commands.of_program (echo 3).

    Fixpoint echo_system (fuel : nat) : System.t :=
      match fuel with
      | O => System.Ret
      | S fuel =>
        System.Send Command.ConsoleRead (fun _ =>
          LString.s "hello " ++ LString.of_N 10 8 None (N.of_nat fuel)) (fun _ =>
          System.Send Command.ConsoleWrite (fun _ => true) (fun _ =>
            echo_system fuel))
      end.
    Compute Trace.run (echo 3) (echo_system 3).
  End Repeat.
End Examples.

(*Module SpecC.
  Inductive t : Type -> Commands.t -> Type :=
  | Ret : forall {A : Type}, A -> t A Commands.Ret
  | Bind : forall {A B : Type} {commands_x commands_y : Commands.t},
    t A commands_x -> (A -> t B commands_y) -> t B (Commands.Bind commands_x commands_y)
  | Send : forall (command : Command.t) (commands : Command.answer command -> Commands.t),
    Command.request command ->
    (forall (answer : Command.answer command), t unit (commands answer)) ->
    t unit (Commands.Send command commands).
  
  Fixpoint run {A : Type} {commands : Commands.t} (x : t A commands) : A :=
    match x with
    | Ret <%= "_" if version[0..2] == "8.4" %> x => x
    | Bind <%= "_ _ _ _" if version[0..2] == "8.4" %> x f => run (f (run x))
    | Send _ _ _ _ => tt
    end.
End SpecC.

Module SpecSystem.
  Inductive t : Commands.t -> Type :=
  | Ret : t Commands.Ret
  | Bind : forall {A B : Type} {commands_x commands_y : Commands.t},
    t commands_x -> t commands_y -> t (Commands.Bind commands_x commands_y)
  | Send : forall (command : Command.t) {commands : Command.answer command -> Commands.t},
    (Command.request command -> {answer : Command.answer command & t (commands answer)}) ->
    t (Commands.Send command commands).
End SpecSystem.

(*Module SpecTrace.
  Inductive t : Type :=
  | Ret : t
  | Bind : t -> t -> t
  | Send : forall (command : Command.t),
    Command.request command -> Command.answer command -> t -> t.

  Fixpoint run {A : Type} {commands : Commands.t} (x : SpecC.t A commands) (system : SpecSystem.t commands)
    : t :=
    match x with
    | SpecC.Ret _ _ =>
      match system with
      | SpecSystem.Ret => Ret
      end
    | SpecC.Bind _ _ _ _ x f =>
      match system with
      | System.Bind system_x system_f =>
        Option.bind (run x system_x) (fun trace_x =>
        Option.bind (run (f @@ C.run x) system_f) (fun trace_y =>
        Some (Bind trace_x trace_y)))
      | _ => None
      end
    | SpecC.Send command commands request handler =>
      match system with
      | System.Send system_command system_handler =>
        match Command.eq_dec system_command command with
        | left Heq =>
          let system_handler := eq_rect system_command (fun c => Command.request c -> Command.answer c * System.t)
            system_handler command Heq in
          let (answer, system) := system_handler request in
          Option.bind (run (handler answer) system) (fun trace_handler =>
          Some (Send command request answer trace_handler))
        | right _ => None
        end
      | _ => None
      end
    end.

    destruct commands.
    - exact Ret.
    - inversion_clear x; inversion_clear s.
      exact (
        let trace_x := run _ _ X X1 in
        let trace_y := run _ _ (X0 (SpecC.run X)) X2 in
        Bind trace_x trace_y).
    - generalize s; clear s.
      inversion x.
      inversion_clear s.
      assert (commands0 = t0).
      injection H2.
      refine (
        let (answer, s) := X0 H1 in
        let x := X answer in
        let traces := run _ _ x s in
        Send command H answer traces).
End SpecTrace.
    

Module System.
  Inductive t : Commands.t -> Type :=
  | Ret : t Commands.Ret
  | Bind : forall {commands_x commands_y : Commands.t},
    t commands_x -> t commands_y -> t (Commands.Bind commands_x commands_y)
  | Send : forall (command : Command.t)
    (handler : Command.answer command -> Commands.t),
    (Command.request command ->
      {answer : Command.answer command & t (handler answer)}) ->
    t (Commands.Send command handler).

  Fixpoint run {A : Type} (x : C.t A) (s : t (Commands.eval x)) : A.
    destruct x as [A x | A B x f | ].
    - exact x.
    - simpl in s.
      inversion_clear s.
      exact (
        let _ := run _ x X in
        run _ (f (C.run x)) X0).
    - simpl in s.
      inversion s.
      refine (let (answer, s_answer) := X r in
        run _ (t0 answer) _).
      assert (handler0 = (fun answer : Command.answer command => Commands.eval (t0 answer))).
      congruence.
intuition.

      assert (answer0 ).
      Check
        let (answer, s_answer) := X r in
        run _ (t0 answer) s_answer.
      

  Fixpoint run {A : Type} (x : C.t A) : t (snd (Outputs.run x)) -> A :=
    match x in C.t A return t (snd (Outputs.run x)) -> A with
    | C.Ret _ x => fun _ => x
    | C.Bind _ _ x f => fun s =>
      match s in t (Outputs.Bind _ _) return A with
      | Bind _ _ s_x s_f =>
        let x := run x s_x in
        run (f x) s_f
      end
    end.
End System.*)*)