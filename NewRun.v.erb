Require Import Coq.Lists.List.
Require Import Coq.Lists.Streams.
Require Import Computation.
Require Import Events.

Import ListNotations.

Module Oracle.
  Definition t (sig : Signature.t) : Type :=
    Stream (forall (command : Command.t) (A : Type),
      list (Command.answer command * A * Memory.t sig)).
End Oracle.

(** The type of an input. *)
Module Input.
  (** An input is a command and an argument. *)
  Record t : Set := New {
    command : Command.t;
    argument : Command.answer command}.
End Input.

(** The type of an output. *)
Module Output.
  (** An output is a command and an argument. *)
  Record t : Set := New {
    command : Command.t;
    argument : Command.request command}.
End Output.

(*Module Request.
  Definition t (sig : Sig.t) : Type := New {
    A : Type;
    command : Command.t;
    request : }.

  forall {A : Type} (command : Command.t), Command.request command ->
    A -> (A -> Command.answer command -> t sig (option A))
End Request.*)

Module Outputs.
  Inductive t (sig : Signature.t) : Type :=
  | Nil : t sig
  | Bind : t sig -> t sig -> t sig
  | Send : forall (S : Type) (command : Command.t),
    S -> Command.request command ->
    (S -> Command.answer command -> Memory.t sig ->
      option S * Memory.t sig * t sig) ->
    t sig.
  Arguments Nil {sig}.
  Arguments Bind {sig} _ _.
  Arguments Send {sig S} _ _ _ _.

  (*Fixpoint eval_mem {sig : Signature.t} (outputs : t sig) : Memory.t sig :=
    match outputs with
    | Nil mem => mem
    | Bind _ outputs => eval_mem outputs
    | Send _ _ _ _ _ mem => mem
    end.

  Module Seq.
    Inductive t (sig : Signature.t) : Type :=
    | Nil : t sig
    | Bind : t sig -> t sig -> t sig
    | Send : forall (command : Command.t), Command.request command ->
      list (t sig) -> t sig.

    Fixpoint run {sig : Signature.t} (oracle : Oracle.t sig)
      (outputs : Outputs.t sig) : t sig :=
      match outputs with
      | Nil _ => 
      end.
  End Seq.*)
End Outputs.

(** Run a computation. *)
Fixpoint run {sig : Signature.t} {A : Type} (mem : Memory.t sig) (x : C.t sig A)
  : A * Memory.t sig * Outputs.t sig :=
  match x in C.t _ A return A  * _ * _ with
  | C.Ret <%= "_" if version[0..2] == "8.4" %> x =>
    (x, mem, Outputs.Nil)
  | C.Bind <%= "_ _" if version[0..2] == "8.4" %> x f =>
    match run mem x with
    | (x, mem, outputs_x) =>
      match run mem (f x) with
      | (y, mem, outputs_y) => (y, mem, Outputs.Bind outputs_x outputs_y)
      end
    end
  | C.Read <%= "_" if version[0..2] == "8.4" %> _ =>
    (Ref.read mem, mem, Outputs.Nil)
  | C.Write <%= "_" if version[0..2] == "8.4" %> _ v =>
    (tt, Ref.write mem v, Outputs.Nil)
  | C.Send <%= "_" if version[0..2] == "8.4" %> command request a handler =>
    (tt, mem, Outputs.Send command a request (fun a answer mem =>
      run mem (handler a answer)))
  end.
