Require Import Coq.Lists.List.
Require Import Coq.Lists.Streams.
Require Import FunctionNinjas.All.
Require Import Computation.
Require Import Events.

Import ListNotations.

Module Oracle.
  Definition t (sig : Signature.t) : Type :=
    Stream (forall (command : Command.t) (A : Type),
      list (Command.answer command * A * Memory.t sig)).
End Oracle.

(** The type of an input. *)
Module Input.
  (** An input is a command and an argument. *)
  Record t : Set := New {
    command : Command.t;
    argument : Command.answer command}.
End Input.

(** The type of an output. *)
Module Output.
  (** An output is a command and an argument. *)
  Record t : Set := New {
    command : Command.t;
    argument : Command.request command}.
End Output.

(*Module Request.
  Definition t (sig : Sig.t) : Type := New {
    A : Type;
    command : Command.t;
    request : }.

  forall {A : Type} (command : Command.t), Command.request command ->
    A -> (A -> Command.answer command -> t sig (option A))
End Request.*)

Module Outputs.
  Inductive t (sig : Signature.t) : Type :=
  | Nil : Memory.t sig -> t sig
  | Bind : t sig -> t sig -> t sig
  | Send : forall (S : Type) (command : Command.t),
    S -> Command.request command ->
    (S -> Memory.t sig -> Command.answer command -> option S * t sig) ->
    Memory.t sig -> t sig.
  Arguments Nil {sig} _.
  Arguments Bind {sig} _ _.
  Arguments Send {sig S} _ _ _ _ _.

  Fixpoint eval_mem {sig : Signature.t} (outputs : t sig) : Memory.t sig :=
    match outputs with
    | Nil mem => mem
    | Bind _ outputs => eval_mem outputs
    | Send _ _ _ _ _ mem => mem
    end.

  (*Fixpoint eval {sig : Signature.t} {A : Type} (mem : Memory.t)
    (outputs : t sig A) : A * Memory.t sig :=
    match outputs with
    | Nil _ f => f mem
    | Bind _ _ f =>
      match f mem with
      | (_, x, mem) => 
    end.*)

  (*Module Seq.
    Inductive t (sig : Signature.t) : Type :=
    | Nil : t sig
    | Bind : t sig -> t sig -> t sig
    | Send : forall (command : Command.t), Command.request command ->
      list (t sig) -> t sig.

    Fixpoint run {sig : Signature.t} (oracle : Oracle.t sig) (mem : Memory.t sig)
      (outputs : Outputs.t sig)
      : t sig :=
      match outputs with
      end.
  End Seq.*)
End Outputs.

(** Run a computation. *)
Fixpoint run {sig : Signature.t} {A : Type} (mem : Memory.t sig) (x : C.t sig A)
  : A * Outputs.t sig :=
  match x in C.t _ A return A  * _ with
  | C.Ret <%= "_" if version[0..2] == "8.4" %> x =>
    (x, Outputs.Nil mem)
  | C.Bind <%= "_ _" if version[0..2] == "8.4" %> x f =>
    match run mem x with
    | (x, outputs_x) =>
      match run (Outputs.eval_mem outputs_x) (f x) with
      | (y, outputs_y) => (y, Outputs.Bind outputs_x outputs_y)
      end
    end
  | C.Read <%= "_" if version[0..2] == "8.4" %> _ =>
    (Ref.read mem, Outputs.Nil mem)
  | C.Write <%= "_" if version[0..2] == "8.4" %> _ v =>
    (tt, Outputs.Nil @@ Ref.write mem v)
  | C.Send <%= "_" if version[0..2] == "8.4" %> command request a handler =>
    (tt, Outputs.Send command a request (fun a mem answer =>
      run mem (handler a answer))
      mem)
  end.
