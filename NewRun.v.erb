Require Import Coq.Lists.List.
Require Import Coq.Lists.Streams.
Require Import Computation.
Require Import Events.

Import ListNotations.

Module Oracle.
  Definition t (sig : Signature.t) : Type :=
    Stream (forall (command : Command.t), list (Command.answer command)).
End Oracle.

(** The type of an input. *)
Module Input.
  (** An input is a command and an argument. *)
  Record t : Set := New {
    command : Command.t;
    argument : Command.answer command}.
End Input.

(** The type of an output. *)
Module Output.
  (** An output is a command and an argument. *)
  Record t : Set := New {
    command : Command.t;
    argument : Command.request command}.
End Output.

Module Outputs.
  Inductive t (sig : Signature.t) : Type :=
  | Nil : t sig
  | Bind : t sig -> t sig -> t sig
  | Send : forall (S : Type) (command : Command.t),
    S -> Command.request command ->
    (S -> Command.answer command -> Memory.t sig ->
      option S * Memory.t sig * t sig) ->
    t sig.
  Arguments Nil {sig}.
  Arguments Bind {sig} _ _.
  Arguments Send {sig S} _ _ _ _.

  Module Seq.
    Inductive t (sig : Signature.t) : Type :=
    | Nil : t sig
    | Bind : t sig -> t sig -> t sig
    | Send : forall (command : Command.t), Command.request command ->
      list (t sig) -> t sig.
    Arguments Nil {sig}.
    Arguments Bind {sig} _ _.
    Arguments Send {sig} _ _ _.

    Fixpoint run {sig : Signature.t} (oracle : Oracle.t sig) (mem : Memory.t sig)
      (outputs : Outputs.t sig)
      : t sig * Memory.t sig :=
      match outputs with
      | Outputs.Nil => (Nil, mem)
      | Outputs.Bind outputs_x outputs_y =>
        let (outputs_x, mem) := run oracle mem outputs_x in
        let (outputs_y, mem) := run oracle mem outputs_y in
        (Bind outputs_x outputs_y, mem)
      | Outputs.Send _ command s request callback =>
        match oracle with
        | Streams.Cons inputs oracle =>
          let inputs := inputs command in
          match List.fold_left (fun s_mem_outputss answer =>
            match s_mem_outputss with
            | (None, _, _) => s_mem_outputss
            | (Some s, mem, outputss) =>
              match callback s answer mem with
              | (s, mem, outputs) =>
                let (outputs, mem) := run oracle mem outputs in
                (s, mem, outputs :: outputss)
              end
            end)
            inputs (Some s, mem, []) with
          | (_, mem, outputss) => (Send command request (List.rev' outputss), mem)
          end
        end
      end.
  End Seq.
End Outputs.

(** Run a computation. *)
Fixpoint run {sig : Signature.t} {A : Type} (mem : Memory.t sig) (x : C.t sig A)
  : A * Memory.t sig * Outputs.t sig :=
  match x in C.t _ A return A  * _ * _ with
  | C.Ret <%= "_" if version[0..2] == "8.4" %> x =>
    (x, mem, Outputs.Nil)
  | C.Bind <%= "_ _" if version[0..2] == "8.4" %> x f =>
    match run mem x with
    | (x, mem, outputs_x) =>
      match run mem (f x) with
      | (y, mem, outputs_y) => (y, mem, Outputs.Bind outputs_x outputs_y)
      end
    end
  | C.Read <%= "_" if version[0..2] == "8.4" %> _ =>
    (Ref.read mem, mem, Outputs.Nil)
  | C.Write <%= "_" if version[0..2] == "8.4" %> _ v =>
    (tt, Ref.write mem v, Outputs.Nil)
  | C.Send <%= "_" if version[0..2] == "8.4" %> command request a handler =>
    (tt, mem, Outputs.Send command a request (fun a answer mem =>
      run mem (handler a answer)))
  end.
