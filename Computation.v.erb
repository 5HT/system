(** The definition of a computation, used to represent concurrent programs. *)
Require Import Coq.NArith.NArith.
Require Import ListString.All.

Module API.
  Record t : Type := New {
    command : Type;
    request : command -> Type;
    answer : command -> Type }.

  Definition add (api1 api2 : t) : t := {|
    command := command api1 + command api2;
    request := fun c =>
      match c with
      | inl c1 => request api1 c1
      | inr c2 => request api2 c2
      end;
    answer := fun c =>
      match c with
      | inl c1 => answer api1 c1
      | inr c2 => answer api2 c2
      end |}.
End API.

(** The id of a client socket. *)
Module ClientSocketId.
  (** A socket id is a natural number. *)
  Inductive t : Set :=
  | New : N -> t.
End ClientSocketId.

Module System.
  (** The list of commands. *)
  Inductive command : Set :=
  | ConsoleRead
  | ConsoleWrite
  | ClientSocketRead.

  (** The type of the parameters of a request. *)
  Definition request (c : command) : Set :=
    match c with
    | ConsoleRead => unit
    | ConsoleWrite => LString.t
    | ClientSocketRead => ClientSocketId.t
    end.

  (** The type of the parameters of an answer. *)
  Definition answer (c : command) : Set :=
    match c with
    | ConsoleRead => LString.t
    | ConsoleWrite => unit
    | ClientSocketRead => LString.t
    end.

  Definition api : API.t := API.New command request answer.
End System .

(** Definition of a computation. *)
Module C.
  Inductive t (api : API.t) : Type -> Type :=
  | Ret : forall {A : Type}, A -> t api A
  | Bind : forall {A B : Type}, t api A -> (A -> t api B) -> t api B
  | Join : forall {A B : Type}, t api A -> t api B -> t api (A * B)
  | First : forall {A B : Type}, t api A -> t api B -> t api (A + B)
  | Send : forall (command : API.command api), API.request api command ->
    t api (API.answer api command).
  Arguments Ret {api A} _.
  Arguments Bind {api A B} _ _.
  Arguments Join {api A B} _ _.
  Arguments First {api A B} _ _.
  Arguments Send _ _ _.

  (** Monadic notations. *)
  Module Notations.
    Notation "'let!' X ':=' A 'in' B" := (Bind A (fun X => B))
      (at level 200, X ident, A at level 100, B at level 200).

    Notation "'let!' X ':' T ':=' A 'in' B" := (Bind (A := T) A (fun X => B))
      (at level 200, X ident, A at level 100, T at level 200, B at level 200).

    Notation "'do!' A 'in' B" := (Bind A (fun _ => B))
      (at level 200, B at level 200).
  End Notations.
End C.
