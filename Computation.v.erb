(** The definition of a computation, used to represent concurrent programs. *)
Require Import Coq.NArith.NArith.
Require Import ListString.All.

Module API.
  Record t : Type := New {
    request : Type;
    answer : request -> Type }.
End API.

Module ClientSocketId.
  Definition t : Set := N.
End ClientSocketId.

Module System.
  Module Request.
    Inductive t : Set :=
    | ConsoleRead : t
    | ConsoleWrite : LString.t -> t
    | ServerSocketBind : N -> t
    | ClientSocketRead : t.
  End Request.

  Module Answer.
    Inductive t : Request.t -> Set :=
    | ConsoleRead : option LString.t -> t Request.ConsoleRead
    | ConsoleWrite : forall {message : LString.t}, bool -> t (Request.ConsoleWrite message)
    | ServerSocketBind : forall {port : N}, ClientSocketId.t -> t (Request.ServerSocketBind port)
    | ClientSocketRead : option LString.t -> t Request.ClientSocketRead.
  End Answer.

  Definition api : API.t := API.New Request.t Answer.t.
End System.

(** Definition of a computation. *)
Module C.
  Inductive t (api : API.t) : Type -> Type :=
  | Ret : forall {A : Type}, A -> t api A
  | Bind : forall {A B : Type}, t api A -> (A -> t api B) -> t api B
  | Join : forall {A B : Type}, t api A -> t api B -> t api (A * B)
  | First : forall {A B : Type}, t api A -> t api B -> t api (A + B)
  | Send : forall (request : API.request api), t api (API.answer api request).
  Arguments Ret {api A} _.
  Arguments Bind {api A B} _ _.
  Arguments Join {api A B} _ _.
  Arguments First {api A B} _ _.
  Arguments Send {api} _.

  (** Monadic notations. *)
  Module Notations.
    Notation "'let!' X ':=' A 'in' B" := (Bind A (fun X => B))
      (at level 200, X ident, A at level 100, B at level 200).

    Notation "'let!' X ':' T ':=' A 'in' B" := (Bind (A := T) A (fun X => B))
      (at level 200, X ident, A at level 100, T at level 200, B at level 200).

    Notation "'do!' A 'in' B" := (Bind A (fun _ => B))
      (at level 200, B at level 200).
  End Notations.
End C.
